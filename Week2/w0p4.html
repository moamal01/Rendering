<!DOCTYPE html>
<html>
  <head>
    <title>W1P4</title>
    <script type="text/javascript" src="w0p4.js"></script>
    <script id="wgsl" type="x-shader">
        struct Uniforms {
          aspect: f32,
          cam_const: f32,
          gamma: f32,
        };
        @group(0) @binding(0) var<uniform> uniforms : Uniforms;

        struct VSOut {
          @builtin(position) position: vec4f,
          @location(0) coords : vec2f,
        };

        @vertex
        fn main_vs(@builtin(vertex_index) VertexIndex : u32) -> VSOut
        {
          const pos = array<vec2f, 4>(vec2f(-1.0, 1.0), vec2f(-1.0, -1.0), vec2f(1.0, 1.0), vec2f(1.0, -1.0));
          var vsOut: VSOut;
          vsOut.position = vec4f(pos[VertexIndex], 0.0, 1.0);
          vsOut.coords = pos[VertexIndex];
          return vsOut;
        }

        struct Ray {
          origin : vec3f,
          direction : vec3f,
          tmin : f32,
          tmax : f32,
        };

        struct HitInfo {
          has_hit: bool,
          dist: f32,
          position: vec3f,
          normal: vec3f,
          color: vec3f,
          shader: u32,
        };

        fn intersect_plane(r: Ray, hit: ptr<function, HitInfo>, position: vec3f, normal: vec3f) -> bool {
          let t_prime = dot((position - r.origin), normal) / dot(r.direction, normal);

          if (t_prime > r.tmin && t_prime < r.tmax) {
            (*hit).has_hit = true;
            (*hit).dist = t_prime;
            (*hit).position = r.origin + t_prime * r.direction;
            (*hit).normal = normal;
            (*hit).color = vec3f(0.1, 0.7, 0.0);
            (*hit).shader = 0;
            return true;
          }

          return false;
        }

        fn intersect_triangle(r: Ray, hit: ptr<function, HitInfo>, v: array<vec3f, 3>) -> bool {
          let e_0 = v[1] - v[0];
          let e_1 = v[2] - v[0];
          let normal = cross(e_0, e_1);

          let cross_result = cross((v[0] - r.origin), r.direction);
          let denominator = dot(r.direction, normal);

          let t_prime = dot((v[0] - r.origin), normal) / denominator;
          let beta = dot(cross_result, e_1) / denominator;
          let gamma = -dot(cross_result, e_0) / denominator;
          let alpha = 1.0 - beta - gamma;

          if (r.tmin < t_prime && r.tmax > t_prime) {
            if (beta >= 0.0 && gamma >= 0.0 && beta + gamma <= 1.0) {
              (*hit).has_hit = true;
              (*hit).dist = t_prime;
              (*hit).position = r.origin + t_prime * r.direction;
              (*hit).normal = normal / length(normal);
              (*hit).color = vec3f(0.4, 0.3, 0.2);
              (*hit).shader = 0;
              return true;
            }
          }

          return false;
        }

        fn intersect_sphere(r: Ray, hit: ptr<function, HitInfo>, center: vec3f, radius: f32) -> bool {
          let origin_minus_center = r.origin - center;

          let a = dot(r.direction, r.direction);
          let b_half = dot(origin_minus_center, r.direction);
          let c = dot(origin_minus_center, origin_minus_center) - radius * radius;

          if b_half * b_half - c < 0 {
            return false;
          }

          let t1_prime = -b_half - sqrt(b_half*b_half - c);
          let p = r.origin + t1_prime * r.direction;
          let normal = p - center;

          if t1_prime > r.tmin && t1_prime < r.tmax {
            //(*hit).has_hit = true;
            // hit.dist = t1_prime;

            (*hit).has_hit = true;
            (*hit).dist = t1_prime;
            (*hit).position = p;
            (*hit).normal = normal / length(normal);
            (*hit).color = vec3f(0.0, 0.0, 0.0);
            (*hit).shader = 0;
            return true;
          }

          let t2_prime = -b_half + sqrt(b_half*b_half - c);

          if t2_prime > r.tmin && t2_prime < r.tmax {
            (*hit).has_hit = true;
            (*hit).dist = t2_prime;
            (*hit).position = r.origin + t2_prime * r.direction;
            (*hit).normal = normal / length(normal);
            (*hit).color = vec3f(0.0, 0.0, 0.0);
            (*hit).shader = 0;
            return true;
          }

          return false;
        }

        fn get_camera_ray(ipcoords: vec2f) -> Ray
        {
          const eye = vec3f(2.0, 1.5, 2.0);
          const p = vec3f(0.0, 0.5, 0.0);
          const u = vec3f(0.0, 1.0, 0.0);

          let v = normalize(p - eye);

          let b1 = normalize(cross(v, u));
          let b2 = cross(b1, v);
          let d = 1.0;

          var ray: Ray;
          ray.origin = eye;
          ray.direction = normalize(ipcoords.x*b1 + ipcoords.y*b2 + d * v);
          ray.tmin = 0.0;
          ray.tmax = 1.0e16;

          return ray;
        }

        fn shade(r: ptr<function, Ray>,hit: ptr<function, HitInfo>) -> vec3f {
          switch (*hit).shader {
          //case 1 { return lambertian(r, hit); }
          //case 2 { return phong(r, hit); }
          //case 3 { return mirror(r, hit); }
          case default { return (*hit).color; }
        }
      }


        fn intersect_scene(r: ptr<function, Ray>, hit : ptr<function, HitInfo>) -> bool {
          // plane
          let position = vec3f(0.0, 0.0, 0.0);
          let normal = vec3f(0.0, 1.0, 0.0);
          let p_color = vec3f(0.1, 0.7, 0.0);

          // triangle
          let v0 = vec3f(-0.2, 0.1, 0.9);
          let v1 = vec3f(0.2, 0.1, 0.9);
          let v2 = vec3f(-0.2, 0.1, -0.1);

          // sphere
          let center = vec3f(0.0, 0.5, 0.0);
          let radius = 0.3;
          let refractive_index = 1.5;
          let shininess = 42;

          // Check if the ray intersects the plane
          if intersect_plane((*r), hit, position, normal) {
            r.tmax = hit.dist;
          }

          if intersect_triangle((*r), hit, array<vec3f, 3>(v0, v1, v2)) {
            r.tmax = hit.dist;
          }

          if intersect_sphere((*r), hit, center, radius) {
            r.tmax = hit.dist;
          }

          return hit.has_hit;
        }

        @fragment
        fn main_fs(@location(0) coords: vec2f) -> @location(0) vec4f {
            const bgcolor = vec4f(0.1, 0.3, 0.6, 1.0);
            const max_depth = 10;
            let uv = vec2f(coords.x*uniforms.aspect*0.5f, coords.y*0.5f);
            var r = get_camera_ray(uv);
            var result = vec3f(0.0);
            var hit = HitInfo(false, 0.0, vec3f(0.0), vec3f(0.0), vec3f(0.0), 0);
            for(var i = 0; i < max_depth; i++) {
                if(intersect_scene(&r, &hit)) {
                    result += shade(&r, &hit);
                } else {
                    result += bgcolor.rgb; break;
                }

                if hit.has_hit {
                    break;
                }
            }

            return vec4f(pow(result, vec3f(1.0/uniforms.gamma)), bgcolor.a);
        }
    </script>
  </head>
  <body>
    <canvas id="webgpu-canvas" width="512" height="512">
      Please use a browser that supports HTML5 canvas.
    </canvas>
  </body>
</html>
